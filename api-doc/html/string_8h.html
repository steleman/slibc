<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>slibc: slibc/string.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">slibc
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_4d4a740b65ecc1faa3510c186d2f00c5.html">slibc</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">string.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains those _s-functions that are related to strings.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;./base_.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="stddef_8h_source.html">./stddef.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="errno_8h_source.html">./errno.h</a>&quot;</code><br/>
</div>
<p><a href="string_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SLIBC_BEGIN_DECLS size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#aab5e41517346e2478a5db9273ab801f7">strnlen_s</a> (const char *s, size_t maxsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The strnlen_s function determines the length of <em>s</em>.  <a href="#aab5e41517346e2478a5db9273ab801f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a8328d88ab6bc728a5d2768340470a86c">strcpy_s</a> (char *restrict s1, rsize_t s1max, const char *restrict s2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The strcpy_s function copies the string <em>s2</em> to <em>s1</em>.  <a href="#a8328d88ab6bc728a5d2768340470a86c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ac6982f578dbc46c470864f175289fec0">strncpy_s</a> (char *restrict s1, rsize_t s1max, const char *restrict s2, rsize_t n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The strncpy_s function copies not more than <em>n</em> characters from <em>s2</em> to <em>s1</em>.  <a href="#ac6982f578dbc46c470864f175289fec0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ae3341e764378a4641f16890366c4e213">strcat_s</a> (char *restrict s1, rsize_t s1max, const char *restrict s2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The strcat_s function copies the string <em>s2</em> to the end of <em>s1</em>.  <a href="#ae3341e764378a4641f16890366c4e213"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a37d94a5d2fb891d453ae0a7c6bf13623">strncat_s</a> (char *restrict s1, rsize_t s1max, const char *restrict s2, rsize_t n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The strncat_s function copies not more than <em>n</em> characters of the string <em>s2</em> to the end of <em>s1</em>.  <a href="#a37d94a5d2fb891d453ae0a7c6bf13623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#aa29fd78a042c805774ecdc5f33adbb78">memcpy_s</a> (void *restrict s1, rsize_t s1max, const void *restrict s2, rsize_t n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The memcpy_s function copies <em>n</em> bytes from buffer <em>s2</em> to buffer <em>s1</em>.  <a href="#aa29fd78a042c805774ecdc5f33adbb78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a94448297a30b4c05885b12bc6983d0c7">memmove_s</a> (void *s1, rsize_t s1max, const void *s2, rsize_t n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The memmove_s function copies <em>n</em> bytes from buffer <em>s2</em> to buffer <em>s1</em> while allowing the buffers to overlap.  <a href="#a94448297a30b4c05885b12bc6983d0c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ada2d37ca45185b9a22f83b54c8550834">strtok_s</a> (char *restrict s1, rsize_t *restrict s1max, const char *restrict delim, char **restrict ptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The strtok_s function breaks a string into smaller strings according to a specified delimiter.  <a href="#ada2d37ca45185b9a22f83b54c8550834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">errno_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a959a94cbf8c2f043f7e3280856ab5bf8">strerror_s</a> (char *s, rsize_t maxsize, errno_t errnum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The strerror_s function returns a human-readable error message for a specified error number.  <a href="#a959a94cbf8c2f043f7e3280856ab5bf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a030fbc40f6427964701b8b57e6d9cbe2">strerrorlen_s</a> (errno_t errnum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The strerrorlen_s function determines the length of the error-message for a specified error number.  <a href="#a030fbc40f6427964701b8b57e6d9cbe2"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Contains those _s-functions that are related to strings. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa29fd78a042c805774ecdc5f33adbb78"></a><!-- doxytag: member="string.h::memcpy_s" ref="aa29fd78a042c805774ecdc5f33adbb78" args="(void *restrict s1, rsize_t s1max, const void *restrict s2, rsize_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errno_t <a class="el" href="string_8h.html#aa29fd78a042c805774ecdc5f33adbb78">memcpy_s</a> </td>
          <td>(</td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>s1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The memcpy_s function copies <em>n</em> bytes from buffer <em>s2</em> to buffer <em>s1</em>. </p>
<p>Unlike the traditional <em>memcpy</em> function <em>memcpy_s</em> accepts a new parameter <em>s1max</em> for specifying the buffer size of <em>s1</em>. A runtime-constraint violation occurrs (instead of a buffer overflow) if <em>s1</em> not large enough to hold <em>n</em> bytes of <em>s2</em>.</p>
<dl class="user"><dt><b>Runtime-constraints:</b></dt><dd>A runtime-constraint violation occurs if <ul>
<li>either <em>s1</em> or <em>s2</em> is a null pointer. </li>
<li><em>s1</em> (as determined by <em>s1max</em>) is not large enough to hold the result. </li>
<li><em>s1</em> and <em>s2</em> overlap.</li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s1</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s1max</td><td>The size of s1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Amount of bytes to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if there was no runtime-constraint violation. Otherwise a non-zero value is returned.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>memcpy </dd></dl>

</div>
</div>
<a class="anchor" id="a94448297a30b4c05885b12bc6983d0c7"></a><!-- doxytag: member="string.h::memmove_s" ref="a94448297a30b4c05885b12bc6983d0c7" args="(void *s1, rsize_t s1max, const void *s2, rsize_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errno_t <a class="el" href="string_8h.html#a94448297a30b4c05885b12bc6983d0c7">memmove_s</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>s1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The memmove_s function copies <em>n</em> bytes from buffer <em>s2</em> to buffer <em>s1</em> while allowing the buffers to overlap. </p>
<p>Unlike the traditional <em>memmove</em> function <em>memmove_s</em> accepts a new parameter <em>s1max</em> for specifying the buffer size of <em>s1</em>. A runtime-constraint violation occurrs (instead of a buffer overflow) if <em>s1</em> not large enough to hold <em>n</em> bytes of <em>s2</em>.</p>
<dl class="user"><dt><b>Runtime-constraints:</b></dt><dd>A runtime-constraint violation occurs if <ul>
<li>either <em>s1</em> or <em>s2</em> is a null pointer. </li>
<li><em>s1</em> (as determined by <em>s1max</em>) is not large enough to hold the result.</li>
</ul>
</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>s1</em> and <em>s2</em> are allowed to overlap.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s1</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s1max</td><td>The size of s1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Amount of bytes to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if there was no runtime-constraint violation. Otherwise a non-zero value is returned.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>memmove </dd></dl>

</div>
</div>
<a class="anchor" id="ae3341e764378a4641f16890366c4e213"></a><!-- doxytag: member="string.h::strcat_s" ref="ae3341e764378a4641f16890366c4e213" args="(char *restrict s1, rsize_t s1max, const char *restrict s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errno_t <a class="el" href="string__templates___8hpp.html#ac67b0a45551b7b4ca8bb38e7a009e691">strcat_s</a> </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>s1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The strcat_s function copies the string <em>s2</em> to the end of <em>s1</em>. </p>
<p>The string concatentation operation will overwrite the existing terminating null byte of <em>s1</em>. The buffer s1 must be large enough to accomodate both for <em>s1</em>, <em>s2</em> and <em>s2's</em> terminating null byte. In contrast to the traditional <em>strcat</em> function, <em>strcat_s</em> expects its caller to explicitly specify the size of the destination buffer <em>s1</em>. This allows the function to check whether the supplied is indeed large enough.</p>
<dl class="user"><dt><b>Runtime-constraints:</b></dt><dd>A runtime-constraint violation occurs if <ul>
<li>either <em>s1</em> or <em>s2</em> is a null pointer. </li>
<li><em>s1</em> (as determined by <em>s1max</em>) is not large enough to hold <em>s1+s2</em>. </li>
<li><em>s1</em> and <em>s2</em> overlap.</li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s1</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s1max</td><td>The size of <em>s1</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The source string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if there was no runtime-constraint violation. Otherwise a non-zero value is returned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>strcat </dd></dl>

<p>Referenced by <a class="el" href="string__templates___8hpp.html#ac67b0a45551b7b4ca8bb38e7a009e691">strcat_s()</a>.</p>

</div>
</div>
<a class="anchor" id="a8328d88ab6bc728a5d2768340470a86c"></a><!-- doxytag: member="string.h::strcpy_s" ref="a8328d88ab6bc728a5d2768340470a86c" args="(char *restrict s1, rsize_t s1max, const char *restrict s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errno_t <a class="el" href="string__templates___8hpp.html#a0c89cb264d58cd861917ba06cd83d8c5">strcpy_s</a> </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>s1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The strcpy_s function copies the string <em>s2</em> to <em>s1</em>. </p>
<p>Unlike the traditional strcpy, the size of the destination buffer <em>s1</em> has to be specified. The function makes sure that it never writes outside the specified bounds.</p>
<p>The buffer <em>s1</em> must be large enough for holding <em>s2</em> plus the terminating null byte.</p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>As long as s1 is not null, the string in <em>s1</em> will always be null-terminated.</dd></dl>
<dl class="user"><dt><b>Runtime-constraints:</b></dt><dd>A runtime-constraint violation occurs if <ul>
<li>either s1 or s2 is a null pointer. </li>
<li>s1 (as determined by s1max) is not large enough to hold <em>s2</em> (including its terminating null byte). </li>
<li>s1 and s2 overlap.</li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s1</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s1max</td><td>The size of s1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The source string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if there was no runtime-constraint violation. Otherwise a non-zero value is returned. </dd></dl>

<p>Referenced by <a class="el" href="string__templates___8hpp.html#a0c89cb264d58cd861917ba06cd83d8c5">strcpy_s()</a>.</p>

</div>
</div>
<a class="anchor" id="a959a94cbf8c2f043f7e3280856ab5bf8"></a><!-- doxytag: member="string.h::strerror_s" ref="a959a94cbf8c2f043f7e3280856ab5bf8" args="(char *s, rsize_t maxsize, errno_t errnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errno_t <a class="el" href="string_8h.html#a959a94cbf8c2f043f7e3280856ab5bf8">strerror_s</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">errno_t&#160;</td>
          <td class="paramname"><em>errnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The strerror_s function returns a human-readable error message for a specified error number. </p>
<p><em>strerror_s</em> copies the message to buffer <em>s</em>. The caller is expected to provide the length of <em>s</em> in parameter <em>maxsize</em>. If the buffer <em>s</em> is not big enough to hold the result, the error message is truncated and the last byte of <em>s</em> is set to the null byte.</p>
<dl class="user"><dt><b>Runtime-constraints:</b></dt><dd>A runtime-constraint violation occurs if <ul>
<li><em>s</em> is a null pointer</li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>destination buffer for the error message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxsize</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errnum</td><td>the error number (typically from errno)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if there was no runtime-constraint violation. Otherwise a non-zero value is returned.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>strerror, strerror_r </dd></dl>

</div>
</div>
<a class="anchor" id="a030fbc40f6427964701b8b57e6d9cbe2"></a><!-- doxytag: member="string.h::strerrorlen_s" ref="a030fbc40f6427964701b8b57e6d9cbe2" args="(errno_t errnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="string_8h.html#a030fbc40f6427964701b8b57e6d9cbe2">strerrorlen_s</a> </td>
          <td>(</td>
          <td class="paramtype">errno_t&#160;</td>
          <td class="paramname"><em>errnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The strerrorlen_s function determines the length of the error-message for a specified error number. </p>
<p>You can use this function to find out how big the buffer passed to strerror_s shall be in order to have a non-truncated error mesage.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errnum</td><td>the error number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The strerrorlen_s function returns the number of characters (not including the null character) in the error-message. </dd></dl>

</div>
</div>
<a class="anchor" id="a37d94a5d2fb891d453ae0a7c6bf13623"></a><!-- doxytag: member="string.h::strncat_s" ref="a37d94a5d2fb891d453ae0a7c6bf13623" args="(char *restrict s1, rsize_t s1max, const char *restrict s2, rsize_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errno_t <a class="el" href="string__templates___8hpp.html#a406937d6abe4c8cd48cb98cd0de85588">strncat_s</a> </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>s1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The strncat_s function copies not more than <em>n</em> characters of the string <em>s2</em> to the end of <em>s1</em>. </p>
<p>The string concatentation operation will overwrite the existing terminating null byte of <em>s1</em>. The buffer s1 must be large enough to accomodate both for <em>s1</em>, <em>s2</em> and s2's terminating null byte. In contrast to the traditional <em>strcat</em> function, <em>strcat_s</em> expects its caller to explicitly specify the size of the destination buffer <em>s1</em>. This allows the function to check whether the supplied is indeed large enough.</p>
<dl class="user"><dt><b>Runtime-constraints:</b></dt><dd>A runtime-constraint violation occurs if <ul>
<li>either <em>s1</em> or <em>s2</em> is a null pointer. </li>
<li><em>s1</em> (as determined by <em>s1max</em>) is not large enough to hold the result. </li>
<li><em>s1</em> and <em>s2</em> overlap.</li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s1</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s1max</td><td>The size of s1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The source string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Maximum amount of characters that should be copied. (If <em>s2</em> is shorter than <em>n</em>, less bytes are copied) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if there was no runtime-constraint violation. Otherwise a non-zero value is returned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>strncat </dd></dl>

<p>Referenced by <a class="el" href="string__templates___8hpp.html#a406937d6abe4c8cd48cb98cd0de85588">strncat_s()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6982f578dbc46c470864f175289fec0"></a><!-- doxytag: member="string.h::strncpy_s" ref="ac6982f578dbc46c470864f175289fec0" args="(char *restrict s1, rsize_t s1max, const char *restrict s2, rsize_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">errno_t <a class="el" href="string__templates___8hpp.html#a473e520b9b3336a8796e1f9f28e098d3">strncpy_s</a> </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>s1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The strncpy_s function copies not more than <em>n</em> characters from <em>s2</em> to <em>s1</em>. </p>
<p>In contrast to <em>strncpy</em> this functions expects the buffer size of <em>s1</em> as a second parameter. The function will never write beyond the specified buffer size.</p>
<dl class="user"><dt><b>Runtime-constraints:</b></dt><dd>A runtime-constraint violation occurs if <ul>
<li>either s1 or s2 is a null pointer. </li>
<li>s1 (as determined by s1max) is not large enough to hold the source (including its terminating null byte). </li>
<li>s1 and s2 overlap.</li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s1</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s1max</td><td>The size of s1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>The source string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Maximum amount of characters that should be copied. (If <em>s2</em> is shorter than <em>n</em>, less bytes are copied)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if there was no runtime-constraint violation. Otherwise a non-zero value is returned. </dd></dl>

<p>Referenced by <a class="el" href="string__templates___8hpp.html#a473e520b9b3336a8796e1f9f28e098d3">strncpy_s()</a>.</p>

</div>
</div>
<a class="anchor" id="aab5e41517346e2478a5db9273ab801f7"></a><!-- doxytag: member="string.h::strnlen_s" ref="aab5e41517346e2478a5db9273ab801f7" args="(const char *s, size_t maxsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SLIBC_BEGIN_DECLS size_t <a class="el" href="string_8h.html#aab5e41517346e2478a5db9273ab801f7">strnlen_s</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The strnlen_s function determines the length of <em>s</em>. </p>
<p>At most maxsize characters are accessed and maxsize is returned. Otherwise the number of characters before the nullbyte are returned. The only difference to <em>strnlen</em> is that in case of <em>s</em> being a null pointer this function gracefully returns 0.</p>
<dl class="user"><dt><b>Runtime-constraints:</b></dt><dd>There are no runtime-constraints.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string of whose length should be calculated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxsize</td><td>Only maxsize characters should be accessed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero if <em>s</em> is a null pointer. <em>Maxsize</em> characters if there is no nullbyte in the first <em>maxsize</em> chars of <em>s</em>. Otherwise the number of characters before the nullbyte. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>strlen, strnlen </dd></dl>

</div>
</div>
<a class="anchor" id="ada2d37ca45185b9a22f83b54c8550834"></a><!-- doxytag: member="string.h::strtok_s" ref="ada2d37ca45185b9a22f83b54c8550834" args="(char *restrict s1, rsize_t *restrict s1max, const char *restrict delim, char **restrict ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="string_8h.html#ada2d37ca45185b9a22f83b54c8550834">strtok_s</a> </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsize_t *restrict&#160;</td>
          <td class="paramname"><em>s1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **restrict&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The strtok_s function breaks a string into smaller strings according to a specified delimiter. </p>
<p>A sequence of strok_s invocations is necessary to break up a string. On the first call, <em>s1</em> points to the buffer to be tokenized, <em>s1max</em> denotes its size, <em>delim</em> points to the delimiter string, <em>ptr</em> points to a caller-provided char pointer. On successive calls, <em>s1</em> should be NULL, while <em>ptr</em> should be unchanged from the previous call.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Please note that the buffer <em>s1</em> will be modified by <em>strok_s</em>. If a delimiter is found in <em>s1</em>, it will be replaced with a null byte.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>on the first call: the buffer to be tokenized. On subsequent calls: Null </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s1max</td><td>on the first call the caller supplies the size of s1 here. on subsequent calls the number is upated to reflect the number of characters in the current oken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>the delimiter </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>used internally by strtok_s in order to maintain state between successive calls of this function</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the first character of a token, or a null pointer if there is no token or there is a runtime-constraint violation.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>strtok, strtok_r </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 31 2012 13:48:20 for slibc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
